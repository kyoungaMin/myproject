# 📊 오늘의 화제 종목 수집 설계서

## 1. 데이터 소스 장단점 비교

### 1.1 yahooquery Screener

| 스크리너 | 설명 | 장점 | 단점 |
|----------|------|------|------|
| **most_actives** | 거래량 상위 종목 | • 객관적 지표<br>• 실시간 데이터<br>• 대형주 중심 | • 항상 비슷한 종목 (AAPL, TSLA 등)<br>• "화제성" 반영 미흡 |
| **day_gainers** | 당일 상승률 상위 | • 모멘텀 파악 용이<br>• 투자자 관심 종목 | • 소형주/페니스탁 포함<br>• 변동성 큼 |
| **day_losers** | 당일 하락률 상위 | • 역발상 투자 기회<br>• 뉴스 이슈 종목 파악 | • 부정적 이미지<br>• 투자자 관심도 낮음 |

**종합 평가:**
```
✅ 안정성: ★★★★★ (Yahoo Finance 공식 데이터)
✅ 실시간성: ★★★★☆ (약간의 딜레이)
✅ 신뢰도: ★★★★★ (검증된 데이터)
✅ 무료 사용: ★★★★★ (API 키 불필요)
⚠️ 화제성 반영: ★★★☆☆ (숫자 기반, 소셜 미반영)
```

---

### 1.2 외부 집계 서비스

| 서비스 | 설명 | 장점 | 단점 |
|--------|------|------|------|
| **ApeWisdom** | WSB 24시간 멘션 순위 | • 실제 커뮤니티 화제성<br>• 개인투자자 관심 반영 | • API 불안정<br>• WSB 편향 (밈주식) |
| **SwaggyStocks** | WSB 감성 분석 | • 감성(긍/부정) 분석<br>• 트렌드 파악 | • 유료 전환<br>• 서비스 지속성 불확실 |

**종합 평가:**
```
✅ 화제성 반영: ★★★★★ (실제 커뮤니티 데이터)
⚠️ 안정성: ★★☆☆☆ (서비스 중단 리스크)
⚠️ 신뢰도: ★★★☆☆ (조작 가능성)
⚠️ 데이터 편향: ★★☆☆☆ (WSB 중심)
❌ 무료 사용: ★★☆☆☆ (제한적)
```

---

## 2. 권장 데이터 소스 선정

### 🏆 권장: yahooquery Screener (Primary) + 복합 점수 시스템

#### 선정 근거

```
┌─────────────────────────────────────────────────────────────┐
│  1️⃣ 서비스 안정성 최우선                                    │
│     → 매일 아침 자동 발송되는 서비스 특성상 안정성 필수      │
│     → Yahoo Finance는 검증된 데이터 제공                    │
│                                                             │
│  2️⃣ 법적/윤리적 리스크 최소화                               │
│     → 외부 서비스 스크래핑은 ToS 위반 가능성                │
│     → yahooquery는 공식 라이브러리                          │
│                                                             │
│  3️⃣ 복합 지표로 "화제성" 보완                               │
│     → 거래량 + 상승률 조합으로 진짜 화제 종목 선별          │
│     → 단순 거래량 많은 종목 vs 급등 종목 균형               │
│                                                             │
│  4️⃣ 확장 가능성                                             │
│     → 추후 뉴스 감성분석 등 자체 화제성 지표 추가 가능      │
└─────────────────────────────────────────────────────────────┘
```

#### 데이터 소스 조합 전략

| 우선순위 | 소스 | 용도 | 비중 |
|----------|------|------|------|
| 1 (필수) | most_actives | 거래량 기반 관심 종목 | 40% |
| 2 (필수) | day_gainers | 상승 모멘텀 종목 | 40% |
| 3 (선택) | day_losers | 이슈/뉴스 종목 | 20% |

---

## 3. yahooquery Screener 사용 코드 예시

### 3.1 기본 사용법

```python
from yahooquery import Screener

def get_trending_stocks():
    """Yahoo Finance에서 화제 종목 가져오기"""
    s = Screener()
    
    # 거래량 상위 종목
    most_actives = s.get_screeners('most_actives', count=25)
    
    # 당일 상승률 상위 종목
    day_gainers = s.get_screeners('day_gainers', count=25)
    
    # 당일 하락률 상위 종목 (선택적)
    day_losers = s.get_screeners('day_losers', count=25)
    
    return {
        'most_actives': most_actives,
        'day_gainers': day_gainers,
        'day_losers': day_losers
    }
```

### 3.2 데이터 파싱 및 정제

```python
from yahooquery import Screener
from typing import List, Dict, Optional
import pandas as pd

def parse_screener_result(screener_data: dict, screener_type: str) -> List[Dict]:
    """
    Screener 결과를 파싱하여 종목 리스트 반환
    
    Args:
        screener_data: Screener API 응답
        screener_type: 'most_actives', 'day_gainers', 'day_losers'
    
    Returns:
        종목 정보 딕셔너리 리스트
    """
    try:
        quotes = screener_data[screener_type]['quotes']
        
        stocks = []
        for quote in quotes:
            stock = {
                'symbol': quote.get('symbol'),
                'name': quote.get('shortName') or quote.get('longName'),
                'price': quote.get('regularMarketPrice'),
                'change_percent': quote.get('regularMarketChangePercent'),
                'volume': quote.get('regularMarketVolume'),
                'market_cap': quote.get('marketCap'),
                'source': screener_type
            }
            stocks.append(stock)
        
        return stocks
    
    except (KeyError, TypeError) as e:
        print(f"파싱 오류 ({screener_type}): {e}")
        return []


def fetch_all_trending_stocks() -> pd.DataFrame:
    """모든 스크리너에서 화제 종목 수집"""
    s = Screener()
    all_stocks = []
    
    screener_types = ['most_actives', 'day_gainers', 'day_losers']
    
    for screener_type in screener_types:
        try:
            data = s.get_screeners(screener_type, count=25)
            stocks = parse_screener_result(data, screener_type)
            all_stocks.extend(stocks)
        except Exception as e:
            print(f"스크리너 오류 ({screener_type}): {e}")
            continue
    
    df = pd.DataFrame(all_stocks)
    return df
```

---

## 4. TOP 1 종목 선정 로직

### 4.1 복합 점수 시스템 (Composite Score)

```python
import pandas as pd
import numpy as np
from typing import Optional, Dict

def calculate_composite_score(df: pd.DataFrame) -> pd.DataFrame:
    """
    복합 점수 계산: 거래량 + 상승률 + 출현 빈도
    
    점수 산정 기준:
    - 거래량 순위 점수 (0-100): 거래량이 높을수록 높은 점수
    - 상승률 점수 (0-100): 상승률이 높을수록 높은 점수 (음수는 0)
    - 출현 빈도 보너스: 여러 스크리너에 등장 시 가산점
    """
    
    if df.empty:
        return df
    
    # 종목별 집계 (중복 제거 및 출현 횟수 계산)
    agg_df = df.groupby('symbol').agg({
        'name': 'first',
        'price': 'first',
        'change_percent': 'max',  # 가장 높은 변동률 사용
        'volume': 'max',          # 가장 높은 거래량 사용
        'market_cap': 'first',
        'source': 'count'         # 출현 횟수
    }).reset_index()
    
    agg_df.rename(columns={'source': 'appearance_count'}, inplace=True)
    
    # 1. 거래량 순위 점수 (0-100)
    agg_df['volume_score'] = agg_df['volume'].rank(pct=True) * 100
    
    # 2. 상승률 점수 (0-100, 음수는 0 처리)
    agg_df['change_score'] = agg_df['change_percent'].apply(
        lambda x: min(max(x, 0) * 5, 100)  # 20% 상승 = 100점
    )
    
    # 3. 출현 빈도 보너스 (최대 30점)
    agg_df['appearance_bonus'] = (agg_df['appearance_count'] - 1) * 15
    
    # 4. 최종 복합 점수
    agg_df['composite_score'] = (
        agg_df['volume_score'] * 0.4 +      # 거래량 40%
        agg_df['change_score'] * 0.4 +       # 상승률 40%
        agg_df['appearance_bonus'] * 0.2     # 출현 빈도 20%
    )
    
    return agg_df.sort_values('composite_score', ascending=False)


def select_top_stock(df: pd.DataFrame, 
                     min_market_cap: float = 1e9,
                     exclude_symbols: list = None) -> Optional[Dict]:
    """
    TOP 1 종목 선정
    
    필터링 조건:
    1. 시가총액 최소 10억 달러 (페니스탁 제외)
    2. 제외 종목 리스트 (ETF, 레버리지 등)
    3. 복합 점수 최고 종목 선택
    """
    
    if exclude_symbols is None:
        exclude_symbols = [
            'SPY', 'QQQ', 'IWM',  # 주요 ETF
            'TQQQ', 'SQQQ', 'UVXY',  # 레버리지/인버스
        ]
    
    scored_df = calculate_composite_score(df)
    
    if scored_df.empty:
        return None
    
    # 필터링
    filtered_df = scored_df[
        (scored_df['market_cap'] >= min_market_cap) &
        (~scored_df['symbol'].isin(exclude_symbols))
    ]
    
    if filtered_df.empty:
        # 필터 완화: 시가총액 조건만 제거
        filtered_df = scored_df[~scored_df['symbol'].isin(exclude_symbols)]
    
    if filtered_df.empty:
        return None
    
    # TOP 1 선택
    top_stock = filtered_df.iloc[0].to_dict()
    
    return top_stock
```

### 4.2 TOP N 종목 선정 (확장)

```python
def select_top_n_stocks(df: pd.DataFrame, 
                        n: int = 5,
                        min_market_cap: float = 1e9,
                        exclude_symbols: list = None) -> list:
    """
    TOP N 종목 선정 (브리핑용)
    
    다양성 확보:
    - 동일 섹터 최대 2개 제한
    - 상승/하락 종목 균형 (선택적)
    """
    
    if exclude_symbols is None:
        exclude_symbols = ['SPY', 'QQQ', 'IWM', 'TQQQ', 'SQQQ', 'UVXY']
    
    scored_df = calculate_composite_score(df)
    
    # 필터링
    filtered_df = scored_df[
        (scored_df['market_cap'] >= min_market_cap) &
        (~scored_df['symbol'].isin(exclude_symbols))
    ]
    
    # TOP N 선택
    top_stocks = filtered_df.head(n).to_dict('records')
    
    return top_stocks
```

---

## 5. 엣지 케이스 처리

### 5.1 종합 예외 처리 클래스

```python
from yahooquery import Screener
from typing import List, Dict, Optional
import pandas as pd
import time
from datetime import datetime
import logging

# 로깅 설정
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class TrendingStocksFetcher:
    """화제 종목 수집기 (엣지 케이스 처리 포함)"""
    
    DEFAULT_EXCLUDE_SYMBOLS = [
        'SPY', 'QQQ', 'IWM', 'DIA',  # ETF
        'TQQQ', 'SQQQ', 'UVXY', 'SOXL', 'SOXS',  # 레버리지
    ]
    
    def __init__(self, 
                 min_market_cap: float = 1e9,
                 max_retries: int = 3,
                 retry_delay: int = 5):
        self.screener = Screener()
        self.min_market_cap = min_market_cap
        self.max_retries = max_retries
        self.retry_delay = retry_delay
    
    def fetch_with_retry(self, screener_type: str, count: int = 25) -> Optional[dict]:
        """재시도 로직이 포함된 데이터 수집"""
        
        for attempt in range(self.max_retries):
            try:
                data = self.screener.get_screeners(screener_type, count=count)
                
                # 데이터 유효성 검사
                if self._validate_response(data, screener_type):
                    return data
                else:
                    logger.warning(f"유효하지 않은 응답 ({screener_type}), 재시도 {attempt + 1}/{self.max_retries}")
                    
            except Exception as e:
                logger.error(f"API 오류 ({screener_type}): {e}, 재시도 {attempt + 1}/{self.max_retries}")
            
            if attempt < self.max_retries - 1:
                time.sleep(self.retry_delay)
        
        return None
    
    def _validate_response(self, data: dict, screener_type: str) -> bool:
        """응답 데이터 유효성 검사"""
        
        # Case 1: 데이터가 None이거나 빈 딕셔너리
        if not data:
            return False
        
        # Case 2: 스크리너 타입 키가 없음
        if screener_type not in data:
            return False
        
        # Case 3: quotes가 없거나 빈 리스트
        quotes = data.get(screener_type, {}).get('quotes', [])
        if not quotes:
            return False
        
        # Case 4: 필수 필드 확인
        required_fields = ['symbol', 'regularMarketPrice']
        first_quote = quotes[0]
        for field in required_fields:
            if field not in first_quote:
                return False
        
        return True
    
    def _handle_duplicates(self, df: pd.DataFrame) -> pd.DataFrame:
        """중복 종목 처리"""
        
        if df.empty:
            return df
        
        # 중복 시 가장 높은 composite_score 유지
        # (calculate_composite_score에서 이미 처리됨)
        return df.drop_duplicates(subset=['symbol'], keep='first')
    
    def _handle_missing_data(self, stock: dict) -> dict:
        """누락된 데이터 기본값 처리"""
        
        defaults = {
            'symbol': 'UNKNOWN',
            'name': 'Unknown Company',
            'price': 0.0,
            'change_percent': 0.0,
            'volume': 0,
            'market_cap': 0,
        }
        
        for key, default_value in defaults.items():
            if stock.get(key) is None:
                stock[key] = default_value
        
        return stock
    
    def _is_market_open(self) -> bool:
        """미국 시장 개장 여부 확인 (간단 버전)"""
        
        # 주말 체크 (0=월, 6=일)
        today = datetime.now()
        if today.weekday() >= 5:
            return False
        
        return True
    
    def get_top_stock(self, exclude_symbols: list = None) -> Optional[Dict]:
        """
        TOP 1 화제 종목 반환 (모든 엣지 케이스 처리)
        
        Returns:
            종목 정보 딕셔너리 또는 None
        """
        
        if exclude_symbols is None:
            exclude_symbols = self.DEFAULT_EXCLUDE_SYMBOLS
        
        # 모든 스크리너에서 데이터 수집
        all_stocks = []
        screener_types = ['most_actives', 'day_gainers', 'day_losers']
        
        for screener_type in screener_types:
            data = self.fetch_with_retry(screener_type)
            
            if data:
                stocks = self._parse_screener_result(data, screener_type)
                all_stocks.extend(stocks)
        
        # Case: 모든 스크리너 실패
        if not all_stocks:
            logger.error("모든 데이터 소스에서 수집 실패")
            return self._get_fallback_stock()
        
        df = pd.DataFrame(all_stocks)
        
        # 복합 점수 계산 및 TOP 1 선정
        scored_df = self._calculate_composite_score(df)
        
        # 필터링
        filtered_df = scored_df[
            (scored_df['market_cap'] >= self.min_market_cap) &
            (~scored_df['symbol'].isin(exclude_symbols))
        ]
        
        # Case: 필터링 후 종목 없음
        if filtered_df.empty:
            logger.warning("필터링 후 종목 없음, 조건 완화")
            filtered_df = scored_df[~scored_df['symbol'].isin(exclude_symbols)]
        
        if filtered_df.empty:
            logger.warning("제외 종목 필터 후에도 없음, 전체에서 선택")
            filtered_df = scored_df
        
        if filtered_df.empty:
            return self._get_fallback_stock()
        
        top_stock = filtered_df.iloc[0].to_dict()
        return self._handle_missing_data(top_stock)
    
    def _parse_screener_result(self, data: dict, screener_type: str) -> List[Dict]:
        """스크리너 결과 파싱"""
        
        try:
            quotes = data[screener_type]['quotes']
            stocks = []
            
            for quote in quotes:
                stock = {
                    'symbol': quote.get('symbol'),
                    'name': quote.get('shortName') or quote.get('longName'),
                    'price': quote.get('regularMarketPrice'),
                    'change_percent': quote.get('regularMarketChangePercent'),
                    'volume': quote.get('regularMarketVolume'),
                    'market_cap': quote.get('marketCap'),
                    'source': screener_type
                }
                stocks.append(stock)
            
            return stocks
        except (KeyError, TypeError):
            return []
    
    def _calculate_composite_score(self, df: pd.DataFrame) -> pd.DataFrame:
        """복합 점수 계산"""
        
        if df.empty:
            return df
        
        agg_df = df.groupby('symbol').agg({
            'name': 'first',
            'price': 'first',
            'change_percent': 'max',
            'volume': 'max',
            'market_cap': 'first',
            'source': 'count'
        }).reset_index()
        
        agg_df.rename(columns={'source': 'appearance_count'}, inplace=True)
        
        # 점수 계산
        agg_df['volume_score'] = agg_df['volume'].rank(pct=True) * 100
        agg_df['change_score'] = agg_df['change_percent'].apply(
            lambda x: min(max(x if pd.notna(x) else 0, 0) * 5, 100)
        )
        agg_df['appearance_bonus'] = (agg_df['appearance_count'] - 1) * 15
        
        agg_df['composite_score'] = (
            agg_df['volume_score'] * 0.4 +
            agg_df['change_score'] * 0.4 +
            agg_df['appearance_bonus'] * 0.2
        )
        
        return agg_df.sort_values('composite_score', ascending=False)
    
    def _get_fallback_stock(self) -> Dict:
        """폴백: 데이터 수집 실패 시 기본값"""
        
        logger.warning("폴백 종목 반환 (데이터 수집 실패)")
        
        return {
            'symbol': 'SPY',
            'name': 'SPDR S&P 500 ETF Trust',
            'price': 0.0,
            'change_percent': 0.0,
            'volume': 0,
            'market_cap': 0,
            'composite_score': 0,
            'is_fallback': True  # 폴백 여부 표시
        }
```

### 5.2 엣지 케이스 정리표

| 케이스 | 상황 | 처리 방법 |
|--------|------|----------|
| **데이터 없음** | API 응답 실패 | 최대 3회 재시도 → 폴백 종목(SPY) |
| **빈 결과** | 스크리너 결과 0건 | 다른 스크리너 결과 사용 |
| **중복 종목** | 여러 스크리너에 동일 종목 | 출현 횟수를 보너스 점수로 활용 |
| **누락 필드** | price, volume 등 None | 기본값(0) 대체 |
| **페니스탁** | 시가총액 매우 낮음 | 시가총액 10억$ 이상만 선정 |
| **ETF/레버리지** | 개별 주식 아님 | 제외 종목 리스트로 필터링 |
| **주말/휴장일** | 시장 미운영 | 가장 최근 거래일 데이터 사용 |
| **네트워크 오류** | 타임아웃, 연결 실패 | 지수 백오프 재시도 |

---

## 6. 최종 사용 예시

```python
# 메인 실행
if __name__ == "__main__":
    fetcher = TrendingStocksFetcher(
        min_market_cap=1e9,  # 10억 달러 이상
        max_retries=3,
        retry_delay=5
    )
    
    # TOP 1 종목 가져오기
    top_stock = fetcher.get_top_stock()
    
    if top_stock:
        print(f"🏆 오늘의 화제 종목: {top_stock['symbol']}")
        print(f"   종목명: {top_stock['name']}")
        print(f"   현재가: ${top_stock['price']:.2f}")
        print(f"   변동률: {top_stock['change_percent']:.2f}%")
        print(f"   거래량: {top_stock['volume']:,}")
        print(f"   복합점수: {top_stock['composite_score']:.1f}")
    else:
        print("❌ 화제 종목 선정 실패")
```

**예상 출력:**
```
🏆 오늘의 화제 종목: NVDA
   종목명: NVIDIA Corporation
   현재가: $142.50
   변동률: 8.32%
   거래량: 458,293,100
   복합점수: 92.4
```

---

> 📅 문서 작성일: 2025년 12월 10일  
> ✍️ 작성자: AI 서비스 기획팀




